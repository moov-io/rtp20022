// Code generated by GoComply XSD2Go for Moov; DO NOT EDIT.
{{- $targetNS := .TargetNamespace }}
{{- $nsPrefix := .Xmlns.PrefixByUri .TargetNamespace }}
{{- $allXmlns := .Xmlns }}
// Models for {{ $targetNS }}{{ if ne $nsPrefix "" }} with prefix '{{ $nsPrefix }}'{{ end }}
package {{ .GoPackageName }}

import (
	"fmt"
	"github.com/moov-io/base"
	"github.com/moov-io/rtp20022/gen/xmldsig"
	"github.com/moov-io/rtp20022/pkg/rtp"
	{{- range .GoImportsNeeded }}
		"{{ . }}"
	{{- end }}
)

{{ if .ExportableElements -}}
	// XSD Elements
{{ end -}}
{{ range .ExportableElements }}
	type {{ .GoName }} struct {
		XMLName xml.Name {{- if eq .GoName "Message" -}}`xml:"Message"`{{- end -}}
		{{- if eq .GoName "Message" }}
			Xmlns []xml.Attr `xml:",attr"`
		{{- end -}}
		{{- if .ContainsText }}
			Value {{ .SimpleContent.Extension.GoName }} `xml:",chardata"`
		{{- end }}
		{{- range .Attributes }}
			{{ .GoName }} {{ if eq .Use "optional" }}*{{ end }}{{ .GoForeignModule }}{{ .GoType }} `xml:"{{ .XmlName }},attr{{ if eq .Use "optional" }},omitempty{{ end }}"`
		{{- end }}
		{{- range .Elements }}
			{{ .GoFieldName }} {{ if .Array }}[]{{ end }}{{ if eq .MinOccurs "0" }}*{{ end }}{{ .GoForeignModule }}{{ .GoTypeName }} `xml:"{{ $targetNS }} {{ .Name }}{{ if eq .MinOccurs "0" }},omitempty{{ end }}"`
		{{- end }}
	}

	{{ $elemLen := len .Elements }}{{ if and (gt $elemLen 0) (ne $nsPrefix "") }}
		// MarshalXML is a custom marshaller that allows us to manipulate the XML tag in order to use the proper namespace prefix
		func (v {{ .GoName }}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
			{{- if .Attributes }}
				var attr = []xml.Attr{}
				{{- range .Attributes }}
				{{ if eq .Use "optional" }}if v.{{ .GoName }} != nil { {{ end }}
					attr = append(attr, xml.Attr{Name: xml.Name{Local: "{{ .XmlName }}"}, Value: {{ if eq .Use "optional" }}*{{ end }}v.{{ .GoName }}},)
				{{ if eq .Use "optional" }} } {{ end }}
				{{- end }}
				e.EncodeToken(xml.StartElement{
					Name: xml.Name{Local: start.Name.Local},
					Attr: attr,
				})
			{{- else }}
				e.EncodeToken(xml.StartElement{Name: xml.Name{Local: start.Name.Local}})
			{{- end }}
			{{- range .Elements }}
				e.EncodeElement(v.{{ .GoFieldName }}, xml.StartElement{Name: xml.Name{Local: "{{ $nsPrefix }}:{{ .Name }}"}})
			{{- end }}
			e.EncodeToken(xml.EndElement{Name: xml.Name{Local: start.Name.Local}})
			return nil
		}
	{{ end }}

	{{ if eq .GoName "Message" }}
		var NamespacePrefixMap = map[string]string{
			{{- range $allXmlns }}
				{{- if and (ne .Prefix "xs") (ne .Prefix "gefeg") }}
					"{{ .Uri }}": "{{ .Prefix }}",
				{{- end }}
			{{- end }}
		}

		{{- range $allXmlns }}
			{{- if and (ne .Prefix "xs") (ne .Prefix "gefeg") (ne .Prefix "head") }}
				{{- $l := len .Uri }}
				{{- $l1 := len (slice (printf "%*s" $l "") 15) }}
				{{- $l2 := len (slice (printf "%*s" $l "") 11) }}
				{{- $l3 := len (slice (printf "%*s" $l "") 10) }}
				{{- $l4 := len (slice (printf "%*s" $l "") 7) }}
				func New{{ title (slice .Uri $l1 $l2) }}{{ slice .Uri $l3 $l4 }}Message() *Message {
					return newMessageForNS("{{ .Uri }}")
				}
			{{ end }}
		{{- end }}

		// UnmarshalXML is a custom unmarshaller that allows us to capture the xmlns attributes
		func (v *{{ .GoName }}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
			for _, attr := range start.Attr {
				if (attr.Name.Space == "" && attr.Name.Local == "xmlns") || (attr.Name.Space == "xmlns") {
					newAttr := xml.Attr{}
					newAttr.Value = attr.Value
					newAttr.Name = xml.Name{}
					if attr.Name.Space == "" {
						newAttr.Name.Local = attr.Name.Local
					} else {
						newAttr.Name.Local = fmt.Sprintf("%s:%s", attr.Name.Space, attr.Name.Local)
					}
					v.Xmlns = append(v.Xmlns, newAttr)
				}
			}

			// Go on with unmarshalling.
			type vv {{ .GoName }}
			return d.DecodeElement((*vv)(v), &start)
		}

		func (v *Message) Body() interface{} {
			{{- range .Elements }}
				{{- if ne .GoFieldName "AppHdr" }}
					if v.{{ .GoFieldName }} != nil {
						return v.{{ .GoFieldName }}
					}
				{{- end }}
			{{- end }}
			return nil
		}
	{{ end }}
{{ end }}

{{ if .ExportableComplexTypes -}}
	// XSD ComplexType declarations
{{ end }}
{{ range .ExportableComplexTypes }}
	{{ if eq .GoName "SignatureEnvelope" }}
		{{ template "SignatureEnvelope" . }}
	{{ else if eq .GoName "HdrAndData" }}
	{{ else if eq .GoName "HdrAndDataTCH" }}
	{{ else if eq .GoName "Document" }}
	{{ else }}
		type {{ .GoName }} struct {
			{{- if eq .GoName "DocumentTCH" }}
				XMLName xml.Name
			{{- end }}
			{{- if .ContainsText }}
				Value {{ .SimpleContent.Extension.GoName }} `xml:",chardata"`
			{{- end }}
			{{- range .Attributes }}
				{{ .GoName }} {{ if eq .Use "optional" }}*{{ end }}{{ .GoForeignModule }}{{ .GoType }} `xml:"{{ .XmlName }},attr{{ if eq .Use "optional" }},omitempty{{ end }}"`
			{{- end }}
			{{- range .Elements }}
				{{- $elemGoForeignModule := .GoForeignModule -}}
				{{- $elemGoTypeName := .GoTypeName -}}
				{{- if or (eq .GoTypeName "ISODate") (eq .GoTypeName "ISODateTime") -}}
					{{- $elemGoForeignModule = "rtp." -}}
				{{- else if eq .GoTypeName "ISONormalisedDateTime" -}}
					{{- $elemGoForeignModule = "rtp." -}}
					{{- $elemGoTypeName = "ISODateTime" -}}
				{{- else if eq .GoTypeName "Max20000Text" -}}
					{{- $elemGoForeignModule = "rtp." -}}
					{{- $elemGoTypeName = "Cdata" -}}
				{{- else if eq .GoTypeName "SignatureEnvelope" -}}
					{{- $elemGoForeignModule = "" -}}
					{{- $elemGoTypeName = "Sgntr" -}}
				{{ end }}
				{{ .GoFieldName }} {{ if .Array }}[]{{ end }}{{ if eq .MinOccurs "0" }}*{{ end }}{{ $elemGoForeignModule }}{{ $elemGoTypeName }} `xml:"{{ $targetNS }} {{ .Name }}{{ if eq .MinOccurs "0" }},omitempty{{ end }}"`
			{{- end }}
			{{- if .Sequence }}
				{{- range .Sequence.Any }}
					Item {{ if eq .MinOccurs "0" }}*{{ end }}string `xml:",any{{ if eq .MinOccurs "0" }},omitempty{{ end }}"`
				{{- end }}
			{{- end }}
		}

		{{ $elemLen := len .Elements }}{{ if and (gt $elemLen 0) (ne $nsPrefix "") }}
			// MarshalXML is a custom marshaller that allows us to manipulate the XML tag in order to use the proper namespace prefix
			func (v {{ .GoName }}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
				{{- if .Attributes }}
					var attr = []xml.Attr{}
					{{- range .Attributes }}
					{{ if eq .Use "optional" }}if v.{{ .GoName }} != nil { {{ end }}
						attr = append(attr, xml.Attr{Name: xml.Name{Local: "{{ .XmlName }}"}, Value: {{ if eq .Use "optional" }}*{{ end }}v.{{ .GoName }}},)
					{{ if eq .Use "optional" }} } {{ end }}
					{{- end }}
					e.EncodeToken(xml.StartElement{
						Name: xml.Name{Local: start.Name.Local},
						Attr: attr,
					})
				{{- else }}
					e.EncodeToken(xml.StartElement{Name: xml.Name{Local: start.Name.Local}})
				{{- end }}
				{{- range .Elements }}
					e.EncodeElement(v.{{ .GoFieldName }}, xml.StartElement{Name: xml.Name{Local: "{{ $nsPrefix }}:{{ .Name }}"}})
				{{- end }}
				e.EncodeToken(xml.EndElement{Name: xml.Name{Local: start.Name.Local}})
				return nil
			}
		{{ end }}
	{{ end }}
{{ end }}

{{ if .ExportableSimpleTypes -}}
	// XSD SimpleType declarations
{{ end }}
{{ range .ExportableSimpleTypes }}
	{{ if eq .GoName "ActiveCurrencyAndAmountSimpleType" }}
		{{ template "ActiveCurrencyAndAmountSimpleType" . }}
	{{ else if eq .GoName "ActiveOrHistoricCurrencyAndAmountSimpleType" }}
		{{ template "ActiveOrHistoricCurrencyAndAmountSimpleType" . }}
	{{ else if eq .GoName "ISODate" }}
	{{ else if eq .GoName "ISODateTime" }}
	{{ else if eq .GoName "ISONormalisedDateTime" }}
	{{ else if eq .GoName "Max20000Text" }}
	{{ else }}
		type {{ .GoName }} {{ .GoTypeName }}
	{{ end }}

	{{- $simpleType := . -}}
	{{- range .Enums }}
		const {{ $simpleType.GoName -}} {{- .GoName }} {{ $simpleType.GoName }} = "{{ .XmlName }}"
	{{- end }}
{{ end }}

{{ define "ActiveCurrencyAndAmountSimpleType" }}

	type ActiveCurrencyAndAmountSimpleType rtp.Amount

	func (a ActiveCurrencyAndAmountSimpleType) MarshalText() ([]byte, error) {
		return rtp.Amount(a).MarshalText()
	}
{{ end }}

{{ define "ActiveOrHistoricCurrencyAndAmountSimpleType" }}

	type ActiveOrHistoricCurrencyAndAmountSimpleType rtp.Amount

	func (a ActiveOrHistoricCurrencyAndAmountSimpleType) MarshalText() ([]byte, error) {
		return rtp.Amount(a).MarshalText()
	}
{{ end }}

{{ define "SignatureEnvelope" }}

	type Sgntr struct {
		Signature *xmldsig.Signature `xml:"http://www.w3.org/2000/09/xmldsig# Signature"`
	}

	// MarshalXML is a custom marshaller that allows us to manipulate the XML tag in order to use the proper namespace prefix
	func (v Sgntr) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
		e.EncodeToken(xml.StartElement{Name: xml.Name{Local: start.Name.Local}})
		e.EncodeElement(v.Signature, xml.StartElement{Name: xml.Name{Local: "ds:Signature"}})
		e.EncodeToken(xml.EndElement{Name: xml.Name{Local: start.Name.Local}})
		return nil
	}
{{ end }}
